---
import "./hero.css";
import "../styles/laser.css";
---

<section class="k3-hero" aria-label="Kersivo hero">
  <div class="k3-bg" aria-hidden="true">
    <div class="k3-bg__spot"></div>
    <div class="k3-bg__grid"></div>
    <div class="k3-bg__grain"></div>
  </div>

  <div class="k3-wrap">
    <div class="k3-center">
      <div class="k3-badges" data-reveal>
        <span class="k3-badge">
          <span class="k3-badge__dot" aria-hidden="true"></span>
          Now booking: 2 project slots
        </span>
      </div>

      <h1 class="k3-h1" data-reveal>
        We craft <span class="k3-grad">high-end</span><br class="k3-br" />
        websites that <span class="k3-grad2 k3-underline">convert</span>.
      </h1>

      <p class="k3-sub" data-reveal>
        Premium design, ruthless performance, and clear messaging — built for UK small businesses.
      </p>

      <div class="k3-cta" data-reveal>
        <a class="k-btn k-btn--primary" href="#contact" data-magnetic>
          <span class="k-btn__label">Get a quote</span>
          <span class="k-btn__shine" aria-hidden="true"></span>
          <span class="k-btn__arrow" aria-hidden="true">→</span>
        </a>

        <a class="k-btn k-btn--ghost" href="#work">
          <span class="k-btn__label">View work</span>
          <span class="k-btn__arrow2" aria-hidden="true">→</span>
        </a>
      </div>

      <div class="k-pills" data-reveal aria-label="Key benefits">
        <span class="k-pill k-pill--accent">SEO foundations</span>
        <span class="k-pill">Astro-fast builds</span>
        <span class="k-pill">Mobile-first</span>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const hero = document.querySelector(".k3-hero");
      if (!hero) return;

      const reduced =
        window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;

      // reveal
      const items = hero.querySelectorAll("[data-reveal]");
      if (items.length) hero.classList.add("k3-reveal");

      if (reduced) {
        items.forEach((el) => el.classList.add("is-in"));
      } else {
        const io = new IntersectionObserver(
          (entries) => {
            entries.forEach((en) => {
              if (en.isIntersecting) {
                en.target.classList.add("is-in");
                io.unobserve(en.target);
              }
            });
          },
          { threshold: 0.18 }
        );

        items.forEach((el, i) => {
          el.style.setProperty("--d", i * 75 + "ms");
          io.observe(el);
        });
      }

      // subtle cursor spotlight — FIXED (no dead zone)
      if (!reduced) {
        let rect = null;
        let rectDirty = true;

        let lastX = 0;
        let lastY = 0;
        let raf = 0;
        let inside = false;

        const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

        const readRect = () => {
          rect = hero.getBoundingClientRect();
          rectDirty = false;
        };

        const paint = () => {
          raf = 0;
          if (!rect || rectDirty) readRect();
          if (!rect || rect.width <= 0 || rect.height <= 0) return;

          const x = ((lastX - rect.left) / rect.width) * 100;
          const y = ((lastY - rect.top) / rect.height) * 100;

          // clamp stops weird values when you skim edges
          hero.style.setProperty("--mx", clamp(x, 0, 100).toFixed(2) + "%");
          hero.style.setProperty("--my", clamp(y, 0, 100).toFixed(2) + "%");
        };

        // mark rect dirty on layout changes
        const markDirty = () => (rectDirty = true);
        window.addEventListener("resize", markDirty, { passive: true });
        window.addEventListener("scroll", markDirty, { passive: true });

        // optional: if hero changes size due to fonts / responsive
        if ("ResizeObserver" in window) {
          const ro = new ResizeObserver(() => (rectDirty = true));
          ro.observe(hero);
        }

        // track pointer globally, but only update when pointer is over hero
        window.addEventListener(
          "pointermove",
          (e) => {
            lastX = e.clientX;
            lastY = e.clientY;

            const el = document.elementFromPoint(lastX, lastY);
            const nowInside = !!(el && hero.contains(el));

            if (!nowInside) {
              inside = false;
              return;
            }

            // just entered hero area -> refresh rect once
            if (!inside) {
              inside = true;
              rectDirty = true;
            }

            if (!raf) raf = requestAnimationFrame(paint);
          },
          { passive: true }
        );
      }

      // magnetic CTA
      const mag = hero.querySelector("[data-magnetic]");
      if (mag && !reduced) {
        const strength = 10;
        const onLeave = () => {
          mag.style.setProperty("--tx", "0px");
          mag.style.setProperty("--ty", "0px");
        };
        const onMove = (e) => {
          const r = mag.getBoundingClientRect();
          const dx = (e.clientX - (r.left + r.width / 2)) / (r.width / 2);
          const dy = (e.clientY - (r.top + r.height / 2)) / (r.height / 2);
          mag.style.setProperty("--tx", (dx * strength).toFixed(2) + "px");
          mag.style.setProperty("--ty", (dy * strength).toFixed(2) + "px");
        };
        mag.addEventListener("pointerleave", onLeave, { passive: true });
        mag.addEventListener("pointermove", onMove, { passive: true });
      }
    })();
  </script>
</section>
