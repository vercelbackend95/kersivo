---
import "./hero.css";
import "./laser.css";

import CtaButton from "../../ui/CtaButton/CtaButton.astro";
import Pill from "../../ui/Pill/Pill.astro";
---

<section class="k3-hero" aria-label="Kersivo hero">
  <div class="k3-wrap">
    <div class="k3-center">
      <div class="k3-badges" data-reveal>
        <span class="k3-badge">
          <span class="k3-badge__dot" aria-hidden="true"></span>
          Now booking: 2 project slots
        </span>
      </div>

      <h1 class="k3-h1" data-reveal>
        <span class="k3-line">
          We craft <span class="k3-grad">high-end</span>
        </span>

        <span class="k3-line">
          websites that
        </span>

        <span class="k3-line k3-line--swap">
          <span class="k3-underline k3-wordSwap" data-rotating-word>
            <span class="k3-grad2" data-word-inner>convert</span>
          </span>
        </span>
      </h1>

      <p class="k3-sub" data-reveal>
        Premium design, ruthless performance, and clear messaging â€” built for UK small businesses.
      </p>

      <div class="k3-cta" data-reveal>
        <CtaButton href="/contact/#contact" label="Get a quote" variant="primary" />
        <CtaButton href="#work" label="View work" variant="ghost" magnetic={false} />
      </div>

      <div class="k-pills" data-reveal aria-label="Key benefits">
        <Pill label="SEO foundations" variant="accent" />
        <Pill label="Astro-fast builds" />
        <Pill label="Mobile-first" />
      </div>
    </div>
  </div>

  <script>
    (() => {
      const hero = document.querySelector(".k3-hero");
      if (!hero) return;

      const reduced =
        window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;

      // ===== reveal (optional) =====
      const items = hero.querySelectorAll("[data-reveal]");
      if (items.length) hero.classList.add("k3-reveal");

      if (reduced) {
        items.forEach((el) => el.classList.add("is-in"));
      } else {
        const io = new IntersectionObserver(
          (entries) => {
            entries.forEach((en) => {
              if (en.isIntersecting) {
                en.target.classList.add("is-in");
                io.unobserve(en.target);
              }
            });
          },
          { threshold: 0.18 }
        );

        items.forEach((el, i) => {
          el.style.setProperty("--d", i * 75 + "ms");
          io.observe(el);
        });
      }

      // ===== laser-synced word swap =====
      const wrap = hero.querySelector("[data-rotating-word]");
      const inner = hero.querySelector("[data-word-inner]");
      const h1 = hero.querySelector(".k3-h1");
      if (!wrap || !inner || !h1) return;

      const words = ["convert", "sell", "rank", "book", "grow", "close", "perform"];

      // --- reserve width in *px* (no ch guessing, no clipping, no drifting)
      const reservePxWidth = () => {
        const meas = document.createElement("span");
        const cs = getComputedStyle(inner);

        meas.style.cssText = [
          "position:absolute",
          "visibility:hidden",
          "white-space:nowrap",
          "pointer-events:none",
          "inset:auto",
          "left:-9999px",
          "top:-9999px"
        ].join(";");

        // match text metrics 1:1
        meas.style.fontFamily = cs.fontFamily;
        meas.style.fontSize = cs.fontSize;
        meas.style.fontWeight = cs.fontWeight;
        meas.style.letterSpacing = cs.letterSpacing;
        meas.style.textTransform = cs.textTransform;
        meas.style.fontStyle = cs.fontStyle;
        meas.style.fontStretch = cs.fontStretch;
        meas.style.fontVariant = cs.fontVariant;

        hero.appendChild(meas);

        let maxW = 0;
        for (const w of words) {
          meas.textContent = w;
          maxW = Math.max(maxW, meas.getBoundingClientRect().width);
        }

        meas.remove();

        // +14px safety for mask/reveal edge + underline padding
        wrap.style.width = Math.ceil(maxW + 14) + "px";
      };

      // initial + responsive (font loading / resize)
      reservePxWidth();
      window.addEventListener("resize", () => reservePxWidth(), { passive: true });
      if (document.fonts && document.fonts.ready) {
        document.fonts.ready.then(() => reservePxWidth()).catch(() => {});
      }

      // laser "hit" moment within cycle
      const HIT = 0.54;

      const readLaserSeconds = () => {
        const v = getComputedStyle(wrap).getPropertyValue("--laser-duration").trim();
        const n = parseFloat(v);
        return Number.isFinite(n) && n > 0 ? n : 2.6;
      };

      let idx = 0;
      let tCycle = 0;
      let tHit = 0;
      let running = false;

      const clearTimers = () => {
        clearTimeout(tCycle);
        clearTimeout(tHit);
        tCycle = 0;
        tHit = 0;
      };

      const swapTo = (next) => {
        inner.classList.remove("is-swapIn");
        void inner.offsetWidth; // restart animation
        inner.textContent = next;
        inner.classList.add("is-swapIn");
      };

      const tick = () => {
        const dur = readLaserSeconds() * 1000;

        tHit = setTimeout(() => {
          idx = (idx + 1) % words.length;
          swapTo(words[idx]);
        }, dur * HIT);

        tCycle = setTimeout(() => {
          clearTimeout(tHit);
          tick();
        }, dur);
      };

      const start = () => {
        if (running) return;
        running = true;
        setTimeout(() => tick(), 120);
      };

      const io2 = new IntersectionObserver(
        (entries) => {
          entries.forEach((e) => {
            if (!e.isIntersecting) return;
            start();
            io2.disconnect();
          });
        },
        { threshold: 0.25 }
      );
      io2.observe(h1);

      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          clearTimers();
          running = false;
        } else {
          start();
        }
      });
    })();
  </script>
</section>
